= OpenShift Pipelines - Staging
:source-highlighter: rouge
:toc: macro
:toclevels: 1

== Learning Objectives

By the end of this section, you will:

* **Understand** how automated staging validation transforms development cycles from weeks to minutes
* **Experience** enterprise-grade security validation with Enterprise Contract and Artifact Signer
* **Trigger** staging pipelines using Git tags and observe automated promotion workflows
* **Learn** how GitOps ensures validated changes reach staging environments automatically

== Understanding Staging Validation Transformation

Enterprise development teams often face significant challenges with staging validation processes:

=== Traditional Staging Challenges

Traditional staging processes create significant delays and uncertainty in the delivery pipeline. Manual validation and coordination typically consume 3-5 days as teams navigate scheduling conflicts and competing priorities. Security reviews and compliance checks add another 1-2 weeks through manual processes that don't scale with increased deployment frequency. Multiple coordination meetings between development, security, and platform teams waste time without adding value, as most discussions could be handled asynchronously. Manual deployment processes prove error-prone and time-consuming, with configuration mistakes and missed steps creating incidents. Perhaps worst of all, "works in staging, fails in production" surprises undermine confidence due to environment inconsistencies that make staging a poor predictor of production behavior.

=== Red Hat Advanced Developer Suite Solution

RHADS fundamentally transforms staging through automation and integration that eliminate manual overhead. Staging time collapses from 3-5 days to just 30 minutes through automated validation pipelines that run consistently without human intervention. Security validation accelerates from 1-2 weeks to mere minutes with Enterprise Contract integrated directly into the pipeline, validating compliance automatically. Manual coordination overhead between teams drops to zero as automated processes replace meetings and email threads. Every staging deployment provides production-ready confidence through consistent, comprehensive validation. Environment surprises disappear as consistent validation ensures staging accurately represents production behavior.

The business benefits compound across the organization. Feature validation accelerates from weeks to hours, directly improving time-to-market and competitive responsiveness. Early risk detection prevents costly production incidents by catching issues when they're cheap to fix. The same security standards apply in staging and production, ensuring audit readiness and eliminating compliance gaps. Platform teams shift focus from deployment coordination to innovation and strategic improvements, multiplying their organizational impact.

== Activity 1: Triggering the Staging Pipeline

Let's create a Git tag to trigger the automated staging pipeline and observe how enterprise validation works.

=== Step 1: Access Your GitLab Repository

* Open your GitLab repository at {gitlab_url}/development/qrks-tkn-{user}[qrks-tkn-{user}^]
* Sign in using:
+
[source,bash,subs="attributes"]
----
Username: {gitlab_user}
Password: {gitlab_user_password}
----
+
image::tekton-stage-1.png[]

=== Step 2: Create a Git Tag

Creating a Git tag simulates a release event that triggers the staging pipeline.

* In the left menu, click on *Code > Tags > New Tag*
+
image::tekton-stage-2.png[]

* Enter a version tag like `v1.0`
* Choose the target branch (typically `main`)
* Click *Create Tag*
+
image::tekton-stage-3.png[]

[NOTE]
====
This tag creation triggers a GitLab webhook that kicks off the OpenShift Pipelines pipeline — the one that promotes the image to the staging environment.
====

=== Alternative: CLI Approach

If you prefer the CLI, you can trigger the same automation:

[source,bash]
----
git tag v1.0
git push --tags
----

The CLI approach does the same thing — triggers the pipeline tied to this Git tag.

=== Step 3: Monitor Pipeline Execution

* Go to Red Hat Developer Hub
* Navigate to the *qrks-tkn-{user}* component
* Click the *CI* tab to see pipeline runs
* Expand the job labeled *promote-to-stage* to follow its progress
+
image::tekton-stage-4.png[]

[TIP]
====
Use the Developer Hub view to observe each task as it executes. You'll see automation in action — no manual approvals, just policy-driven promotion.
====

== Activity 2: Understanding Pipeline Tasks

The staging pipeline provides production-level confidence while eliminating manual bottlenecks* Let's examine each task in detail.

=== Task 1.1: extract-destination-image-tag

**Purpose:** Perfect traceability through Git tags

This task extracts the commit ID of the Git tag* The commit ID becomes the image tag of the image we are promoting to staging, enabling:

* Coordinated feature rollouts
* Complete audit trails for compliance
* End-to-end traceability from code to deployment

=== Task 1.2: gather-images-to-verify

**Purpose:** Ensuring staging mirrors production exactly

This task selects the image based on the commit ID and generates `images.json`, which:

* Ensures same validated images eliminate "works in staging, fails in production" surprises
* Provides a guarantee that staging validation represents real production deployment quality
* Creates mapping between Git commit and container image for complete traceability

[NOTE]
====
This mapping between Git commit and container image provides end-to-end traceability — we know exactly what code went into what image.
====

**Sample `images.json`:**
[source,json,subs="attributes"]
----
{
  "components": [
    {
      "containerImage": "quay.tssc-quay/tssc/qrks-tkn-{user}:abc123def456",
      "source": {
        "git": {
          "url": "{gitlab_url}/development/qrks-tkn-{user}",
          "revision": "abc123def456"
        }
      }
    }
  ]
}
----

=== Task 2: verify-enterprise-contract

**Purpose:** Critical business protection through automated security validation

This step enforces multiple critical validations that protect your business and customers:

**Enterprise Security Validations:**

* **Container image signature verification** using cryptographic signing
* **Software Bill of Materials (SBOM) validation** for supply chain security
* **CVE scanning** to catch security vulnerabilities before production
* **Policy compliance** ensuring enterprise security standards
* **Provenance attestation** to verify source repository integrity

**Business Value:**

This automated security validation delivers measurable business impact. Security validation time plummets from 1-2 weeks to minutes, removing a major bottleneck from the delivery pipeline. Early risk detection prevents costly production incidents by catching vulnerabilities when they're inexpensive to fix. The same security standards apply in staging and production, ensuring audit readiness and eliminating the "staging doesn't match production" gaps that surprise auditors. Automatic CVE scanning and policy compliance happen continuously without manual intervention, providing assurance without adding process overhead.

**Enterprise Impact:**

The enterprise-wide impact transforms how organizations manage security and risk. Security incident prevention improves as issues are caught before customer exposure, protecting brand reputation and customer trust. Audit confidence increases because staging deployments prove production security compliance in advance, turning audits from stressful events into routine validations. Deployment velocity accelerates as security validation completes in minutes instead of weeks, enabling rapid response to market opportunities. Risk mitigation becomes comprehensive through 100% consistent security enforcement across all environments, eliminating the exceptions and configuration drift that create vulnerabilities.

[IMPORTANT]
====
If any check fails, the pipeline halts* If everything passes, the image moves forward to the next promotion step.
====

**Technical Implementation:**

First, the pipeline bootstraps trust using `cosign` and a local TUF (The Update Framework) server:

[source,bash]
----
cosign initialize \
  --mirror https://tuf.tssc-tas.svc \
  --root https://tuf.tssc-tas.svc/root.json
----

Then, the Enterprise Contract CLI performs validation:

[source,bash,subs="attributes"]
----
ec validate image \
  --image quay.tssc-quay/tssc/qrks-tkn-{user}:abc123..* \
  --policy default \
  --public-key k8s://openshift/trusted-keys \
  --output json
----

**Sample validation output:**
[source,json]
----
{
  "successes": [
    "Image is signed and verified with cosign",
    "SBOM (CycloneDX) is present",
    "Provenance attestation matches source repo",
    "No critical vulnerabilities found"
  ],
  "failures": []
}
----

=== Task 3: copy-image

**Purpose:** Quality gateway ensuring only validated images reach staging

This task promotes the validated image with a human-readable tag (e.g., `v1.0`), ensuring:

* Only validated, compliant images reach staging
* Production-grade quality assurance
* No unauthorized image changes slip through

**Technical Implementation:**

[source,bash,subs="attributes"]
----
skopeo copy \
  docker://quay.tssc-quay/tssc/qrks-tkn-{user}:abc123..* \
  docker://quay.tssc-quay/tssc/qrks-tkn-{user}:v1.0
----

[IMPORTANT]
====
This guarantees that only validated artifacts are promoted — no sneaky image changes slip through.
====

=== Task 4: update-deployment

**Purpose:** Automated GitOps bridge for immediate feature validation

This task ensures validated changes reach staging automatically through GitOps, enabling:

* QA teams can test immediately after development completion
* Staging catches configuration issues before production
* No manual coordination needed for deployments
* Staging success reliably predicts production success

[NOTE]
====
No manual `kubectl`, no YAML editing in the console — the system reacts to Git* That's the GitOps advantage.
====

**GitOps Implementation Details:**

The pipeline updates deployment files automatically:

**`kustomization.yaml`:**
[source,yaml]
----
apiVersion: kustomize.config.k8s.io/v1beta1
kind: Kustomization
patchesStrategicMerge:
  - deployment-patch.yaml
resources:
  - ../../base
----

**`deployment-patch.yaml`:**
[source,yaml,subs="attributes"]
----
apiVersion: apps/v1
kind: Deployment
metadata:
  name: qrks-tkn-{user}
spec:
  template:
    spec:
      containers:
        - name: qrks-tkn-{user}
          image: quay.tssc-quay/tssc/qrks-tkn-{user}:v1.0
----

**Example Git diff showing automatic update:**
[source,diff,subs="attributes"]
----
-          image: quay.io/redhat-appstudio/rhtap-task-runner:latest
+          image: quay.tssc-quay/tssc/qrks-tkn-{user}:v1.0
----

== Activity 3: Observing GitOps Deployment

Watch how ArgoCD automatically syncs your validated changes to the staging environment.

ArgoCD (OpenShift GitOps) continuously monitors your GitOps repository and automatically applies any changes to your staging environment. When the pipeline updates deployment manifests, ArgoCD detects these changes and deploys them without any manual intervention - ensuring your staging environment always matches what's defined in Git.

=== Step 1: Verify Deployment Updates

* Access your GitOps repository at {gitlab_url}/development/qrks-tkn-{user}-gitops[qrks-tkn-{user}-gitops^]
* Check the updated deployment manifests in the `components/qrks-tkn-{user}/overlays/stage` directory
* Notice how the image tag has been automatically updated to your release version
* Observe that this happens without any manual intervention

=== Step 2: Monitor ArgoCD Synchronization

* ArgoCD automatically detects the Git changes in your GitOps repository
* ArgoCD syncs these changes to the staging environment
* The deployment completes successfully without manual kubectl commands

=== Step 3: Validate Staging Environment

* Access your staging application through its route
* Verify that your changes are live and functioning correctly
* Confirm that the staging environment matches your expectations

== What You've Learned

You've experienced how Red Hat Advanced Developer Suite transforms enterprise staging validation:

=== Pipeline Task Summary

|===
| Phase | Purpose

| 1.1 extract-destination-image-tag
| Extracts the commit ID of the Git tag* The commit ID is the image tag of the image we are promoting to `stage`.

| 1.2 gather-images-to-verify
| Selects the image based on the commit ID and generates `images.json`.

| 2 verify-enterprise-contract
| Validates signature, SBOM, provenance, CVEs — all enforced via the EC CLI.

| 3 copy-image
| Promotes the validated image with a human-readable tag (e.g., `v1.0`).

| 4 update-deployment
| Updates `overlays/stage` to trigger Argo CD deployment.
|===

=== Key Business Transformation

**Staging Validation Benefits:**

* Staging time: 3-5 days → 30 minutes
* Production-grade validation catches issues early
* Zero manual coordination overhead
* Teams trust staging validation represents production reality

**Enterprise Security Excellence:**

* Automated security validation replaces weeks of manual review
* Complete audit trails for compliance requirements
* Cryptographic proof of image integrity and source
* Consistent security enforcement across all deployments

== What's Next

Your application is now successfully validated and running in staging with enterprise-grade security!

In the next section, you'll experience:

* Production deployment with the same automated validation
* Advanced monitoring and observability features
* Complete audit trails that satisfy enterprise compliance requirements
* Zero-downtime deployment strategies for production environments

The transformation from weeks-long staging cycles to 30-minute automated validation demonstrates the power of Red Hat Advanced Developer Suite in modern enterprise development.


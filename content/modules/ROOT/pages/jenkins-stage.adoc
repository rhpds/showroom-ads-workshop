= Jenkins Pipelines - Staging
:source-highlighter: rouge
:toc: macro
:toclevels: 1

== Learning Objectives

By the end of this section, you will:

* **Understand** how Jenkins staging validation transforms development cycles from days to minutes
* **Experience** enterprise-grade security validation with Enterprise Contract integrated into Jenkins workflows
* **Trigger** Jenkins staging pipelines using Git tags and observe automated promotion workflows
* **Learn** how GitOps ensures validated changes reach staging environments through Jenkins automation
* **See** how Jenkins expertise becomes more valuable with enhanced staging capabilities

== Understanding Jenkins Staging Transformation

Enterprise development teams with significant Jenkins investments often face substantial challenges with staging validation processes:

=== Traditional Jenkins Staging Challenges

Traditional Jenkins staging processes create significant delays and frustration. Manual coordination and deployment typically consume 3-5 days as platform teams juggle competing priorities. Security reviews and compliance checks add another 1-2 weeks to the timeline, with manual processes that don't scale. Multiple coordination meetings between development, platform, and security teams eat up valuable time without adding value. Manual staging processes prove error-prone and time-consuming, with configuration drift that makes debugging difficult. Inconsistent Jenkins configurations across different staging environments mean that "works in my staging" becomes a common refrain when production deployments fail.

=== Red Hat Advanced Developer Suite Solution for Jenkins

RHADS fundamentally transforms the Jenkins staging experience through automation and integration. Staging time collapses from 3-5 days to just 30 minutes through automated Jenkins validation pipelines that eliminate manual coordination. Security validation accelerates from 1-2 weeks to mere minutes with Enterprise Contract integrated directly into Jenkins workflows. Manual coordination overhead drops to zero while your Jenkins expertise remains relevant and valuable. Every staging deployment provides production-ready confidence through consistent, automated validation. Enhanced Jenkins capabilities make your existing skills more valuable rather than obsolete.

The business benefits compound across your organization. Jenkins staging deployment time drops from days to minutes, directly accelerating feature delivery. Security validation integrates into familiar Jenkins workflows rather than disrupting them with unfamiliar tools. Jenkins expertise grows more valuable as it expands to include modern security and compliance practices. Platform teams shift their focus from manual coordination to innovation and strategic improvements, multiplying their organizational impact.

== Activity 1: Triggering the Jenkins Staging Pipeline

Let's create a Git tag to trigger your automated Jenkins staging pipeline and observe how enterprise validation works within familiar Jenkins workflows.

=== Step 1: Access Your GitLab Repository

* Open your GitLab repository at {gitlab_url}/development/qrks-jnk-{user}[qrks-jnk-{user}^
* Sign in using:
+
[source,bash,subs="attributes"]
----
Username: {gitlab_user}
Password: {gitlab_user_password}
----
+
++++
<a href="_images/jenkins-stage-1.png" target="_blank">
  <img src="_images/jenkins-stage-1.png" alt="Click to enlarge" style="width:800px; cursor: zoom-in;">
</a>
++++

=== Step 2: Create a Git Tag for Jenkins Staging

Creating a Git tag triggers your Jenkins staging pipeline, demonstrating how simple actions can activate sophisticated workflows.

* In the left menu, click on *Code > Tags > New Tag*
+
++++
<a href="_images/jenkins-stage-2.png" target="_blank">
  <img src="_images/jenkins-stage-2.png" alt="Click to enlarge" style="width:800px; cursor: zoom-in;">
</a>
++++

* Enter a version tag like `v1.0`
* Choose the target branch (typically `main`)
* Click *Create Tag*
+
++++
<a href="_images/jenkins-stage-3.png" target="_blank">
  <img src="_images/jenkins-stage-3.png" alt="Click to enlarge" style="width:800px; cursor: zoom-in;">
</a>
++++

[NOTE]
====
This tag creation triggers a GitLab webhook that activates your Jenkins staging pipeline 	 the one that promotes the image to the staging environment with enterprise security validation.
====

=== Alternative: CLI Approach for Jenkins

If you prefer the command line approach that many Jenkins users are comfortable with:

[source,bash]
----
git tag v1.0
git push --tags
----

This CLI method triggers the same Jenkins staging automation while maintaining the familiar developer workflow.

=== Step 3: Monitor Jenkins Pipeline Execution

* Navigate to Red Hat Developer Hub
* Go to your `qrks-jnk-{user}` component
* Click the *CI* tab to see your Jenkins pipeline runs
* Look for the job labeled *promote-to-stage* and click *View build* to follow its progress
+
++++
<a href="_images/jenkins-stage-4.png" target="_blank">
  <img src="_images/jenkins-stage-4.png" alt="Click to enlarge" style="width:800px; cursor: zoom-in;">
</a>
++++

* Click *Open Blue Ocean* to view the Jenkins pipeline stages in the familiar interface
+
++++
<a href="_images/jenkins-stage-5.png" target="_blank">
  <img src="_images/jenkins-stage-5.png" alt="Click to enlarge" style="width:800px; cursor: zoom-in;">
</a>
++++

[TIP]
====
Use the Developer Hub view combined with Jenkins Blue Ocean to observe each task as it executes* You'll see enterprise automation in action using familiar Jenkins tools 	 no manual approvals, just policy-driven promotion through enhanced Jenkins workflows.
====

== Activity 2: Understanding Jenkins Pipeline Tasks

Your Jenkins staging pipeline provides production-level confidence while eliminating manual bottlenecks and preserving your Jenkins expertise* Let's examine each task in detail.

++++
<a href="_images/jenkins-stage-6.png" target="_blank">
  <img src="_images/jenkins-stage-6.png" alt="Click to enlarge" style="width:800px; cursor: zoom-in;">
</a>
++++

=== Task 1: gather-images

**Purpose:** Perfect traceability through Git tags in Jenkins workflows

This Jenkins task identifies exactly what needs to be promoted by:

* Resolving the Git tag back to its commit ID for precise tracking
* Matching the commit to the corresponding container image built in development
* Creating an authoritative `images.json` file for the Jenkins validation process

**Business Value for Jenkins Teams:**

This traceability delivers tangible business value across multiple dimensions. Complete staging traceability ensures every Jenkins deployment links directly to specific code changes, eliminating the "what got deployed?" questions that plague troubleshooting. Quality assurance improves because Jenkins staging validates exactly what will reach production, catching environment-specific issues early. Audit readiness becomes automatic with complete Jenkins staging evidence trails that satisfy compliance reviewers without manual documentation. Development confidence grows as teams know precisely what's being validated in Jenkins staging, reducing the uncertainty that slows release decisions.

**Sample `images.json` generated by Jenkins:**
[source,json,subs="attributes"]
----
{
  "components": [
    {
      "containerImage": "quay.tssc-quay/tssc/qrks-jnk-{user}:123456",
      "source": {
        "git": {
          "url": "{gitlab_url}/development/qrks-jnk-{user}",
          "revision": "123456"
        }
      }
    }
  ]
}
----

This mapping provides end-to-end traceability through your Jenkins workflow 	 you know exactly what code went into what image during staging validation.

=== Task 2: verify-ec

**Purpose:** Critical business protection through automated security validation in Jenkins

This Jenkins stage enforces multiple critical validations that protect your business and customers while leveraging familiar Jenkins workflows:

**Enterprise Security Validations in Jenkins:**

* **Digital signature verification** using cryptographic signing integrated with Jenkins
* **Software Bill of Materials (SBOM) validation** for supply chain security
* **CVE scanning** to catch security vulnerabilities before production
* **Organizational policy compliance** ensuring enterprise security standards
* **Provenance attestation** to verify source repository integrity

**Business Value for Jenkins Teams:**

The security validation delivers measurable business impact that matters to executives and customers. Jenkins staging security incidents drop to zero as automated validation catches issues before they reach production, protecting your brand reputation. Consistent standards become automatic as every Jenkins staging deployment meets enterprise security policies without manual oversight. Staging validation accelerates dramatically, happening in minutes rather than weeks, removing a major bottleneck from your delivery pipeline. Production confidence improves as only security-validated features progress from Jenkins staging, reducing the anxiety around releases and enabling faster deployment cycles.

**Technical Implementation in Jenkins:**

Jenkins runs the `verify-ec` stage using the Red Hat Trusted Application Pipeline shared library:

First, Jenkins initializes Cosign trust using a TUF server:
[source,bash]
----
cosign initialize \
  --mirror https://tuf.tssc-tas.dev \
  --root https://tuf.tssc-tas.dev/root.json
----

Then Jenkins validates the image using Enterprise Contract:
[source,bash,subs="attributes"]
----
ec validate image \
  --policy git::github.com/org/ec-policies//default \
  --public-key k8s://openshift/trusted-keys \
  --output json \
  --image quay.tssc-quay/tssc/qrks-jnk-{user}:123456
----

**Sample Jenkins validation output:**
[source,json]
----
{
  "successes": [
    "Image is signed and verified with cosign",
    "SBOM (CycloneDX) is present",
    "Provenance matches repository",
    "No critical vulnerabilities found"
  ],
  "failures": []
}
----

[IMPORTANT]
====
If any security check fails, your Jenkins pipeline stops immediately 	 ensuring no risky code progresses to the next stage* This automated security gate in Jenkins protects your business without manual intervention.
====

=== Task 3: update-image-tag-for-stage

**Purpose:** Quality gateway ensuring only validated images reach staging through Jenkins

This Jenkins task promotes the validated image with a human-readable tag like `v1.0`, creating a critical quality gate in your delivery pipeline. The release version tag signals that this image has passed all enterprise security checks in Jenkins staging, providing clear intent that's visible to everyone. Complete traceability connects source code through to staging deployment via Jenkins processes, eliminating gaps in your audit trail. Only validated, compliant features get tested in staging through Jenkins workflows, ensuring that security is never bypassed under pressure. Staging becomes an accurate production preview using Jenkins-validated images, so success in staging reliably predicts production success.

**Technical Implementation in Jenkins:**

Jenkins uses `skopeo` to copy the image and apply the new tag:
[source,bash,subs="attributes"]
----
skopeo copy \
  docker://quay.tssc-quay/tssc/qrks-jnk-{user}:123456 \
  docker://quay.tssc-quay/tssc/qrks-jnk-{user}:v1.0
----

[IMPORTANT]
====
This Jenkins process guarantees that only validated artifacts are promoted 	 no unauthorized image changes slip through to staging.
====

=== Task 4: deploy-to-stage

**Purpose:** Automated GitOps bridge for immediate feature validation through Jenkins

This Jenkins task ensures validated changes reach staging automatically through GitOps integration, bridging CI and CD seamlessly. GitOps automation eliminates human staging deployment mistakes that occur during manual processes, especially under time pressure. Every staging change becomes tracked and traceable through Jenkins, creating a complete audit trail that satisfies compliance requirements. The deployment method remains consistent for both routine updates and emergency features, preventing the "cowboy deployments" that bypass security. All staging changes follow the same validated Jenkins security process, ensuring no shortcuts create vulnerabilities.

**GitOps Implementation through Jenkins:**

Jenkins updates the staging deployment configuration automatically:

The pipeline uses `rhtap.update_deployment()` to patch the `kustomization.yaml` overlay for stage:

**`kustomization.yaml`:**
[source,yaml]
----
apiVersion: kustomize.config.k8s.io/v1beta1
kind: Kustomization
resources:
  - ../../base
patchesStrategicMerge:
  - deployment-patch.yaml
----

**`deployment-patch.yaml`:**
[source,yaml,subs="attributes"]
----
apiVersion: apps/v1
kind: Deployment
metadata:
  name: qrks-jnk-{user}
spec:
  template:
    spec:
      containers:
        - name: qrks-jnk-{user}
          image: quay.tssc-quay/tssc/qrks-jnk-{user}:v1.0
----

Jenkins commits and pushes this change to the GitOps repository, and Argo CD detects the update and syncs the deployment to the `stage` environment automatically.

[NOTE]
====
No manual `kubectl` commands, no YAML editing in the console 	 Jenkins triggers the GitOps system to react to Git changes* That's the enhanced Jenkins advantage with GitOps integration.
====

== Activity 3: Observing Jenkins-Integrated GitOps Deployment

Watch how your Jenkins pipeline integrates with ArgoCD to automatically sync validated changes to the staging environment.

=== Step 1: Monitor Jenkins Pipeline Progress

* In Jenkins Blue Ocean, observe each stage completing:

  - **gather-images**: Jenkins identifies the exact image to promote
  - **verify-ec**: Jenkins validates enterprise security policies
  - **update-image-tag-for-stage**: Jenkins tags the validated image
  - **deploy-to-stage**: Jenkins updates GitOps manifests automatically

* Notice how the Jenkins interface provides familiar monitoring while handling modern GitOps.

=== Step 2: Verify GitOps Integration

* Access your GitOps repository at {gitlab_url}/development/qrks-jnk-{user}-gitops[qrks-jnk-{user}-gitops^
* Check the updated deployment manifests in the `overlays/stage` directory
* Notice how Jenkins automatically updated the image tag to your release version
* Observe that this GitOps integration happens seamlessly within Jenkins workflows

=== Step 3: Monitor ArgoCD Synchronization

* ArgoCD automatically detects the Git changes made by your Jenkins pipeline
* ArgoCD syncs these changes to the staging environment
* The deployment completes successfully without manual intervention from Jenkins or kubectl commands

=== Step 4: Validate Staging Environment Success

* Access your staging application through its route
* Verify that your changes are live and functioning correctly
* Confirm that the staging environment reflects exactly what Jenkins validated

== What You've Learned

You've experienced how Red Hat Advanced Developer Suite transforms enterprise Jenkins staging validation while preserving valuable team expertise:

=== Jenkins Pipeline Task Summary

|===
| Jenkins Task | Purpose


| gather-images
| Jenkins identifies exact image to promote based on Git tag and commit ID

| verify-ec
| Jenkins validates signature, SBOM, provenance, CVEs using Enterprise Contract CLI

| update-image-tag-for-stage
| Jenkins promotes validated image with human-readable tag (e.g., `v1.0`)

| deploy-to-stage
| Jenkins updates GitOps repository to trigger Argo CD deployment automatically
|===

=== Key Business Transformation for Jenkins Teams

**Enhanced Jenkins Staging Benefits:**

The staging transformation delivers immediate, measurable improvements. Jenkins staging time collapses from 3-5 days to 30 minutes using the familiar tools your team already knows. Production-grade validation catches issues early through Jenkins workflows, preventing costly downstream fixes. Manual coordination overhead drops to zero while your Jenkins expertise remains valuable and relevant. Teams develop trust in Jenkins staging validation as it consistently represents production reality, reducing the fear and uncertainty around releases.

**Enterprise Security Excellence in Jenkins:**

Security excellence becomes automatic rather than aspirational. Automated security validation integrates into familiar Jenkins workflows without forcing process changes. Complete audit trails for compliance generate through normal Jenkins processes, satisfying auditors without manual effort. Cryptographic proof of image integrity and source flows through Jenkins pipelines, providing non-repudiable evidence of your software supply chain. Consistent security enforcement applies across all Jenkins deployments, eliminating the configuration drift that creates vulnerabilities.

**Jenkins Investment Enhancement:**

Your Jenkins investment grows stronger with RHADS integration. Existing Jenkins infrastructure becomes more powerful and valuable rather than legacy technical debt. Jenkins expertise enhances with modern security and GitOps capabilities, making your team's knowledge more marketable and strategically important. Teams continue using familiar Jenkins tools with enhanced automation layered on top, minimizing retraining and productivity loss. Platform efficiency improves dramatically while preserving the Jenkins knowledge and infrastructure investment you've made over years.

== What's Next

Your application is now successfully validated and running in staging with enterprise-grade security through enhanced Jenkins workflows!

In the next section, **Production - Jenkins Pipeline Deployment**, you'll experience:

* Production deployment using familiar Jenkins tools with enhanced security
* Advanced monitoring and observability integrated with Jenkins workflows
* Complete audit trails that satisfy enterprise compliance requirements through Jenkins
* Zero-downtime deployment strategies for production environments using Jenkins automation

The transformation from days-long staging cycles to 30-minute automated validation demonstrates how Red Hat Advanced Developer Suite enhances rather than replaces your valuable Jenkins investment and expertise.

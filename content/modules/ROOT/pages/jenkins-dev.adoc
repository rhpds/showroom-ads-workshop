= Jenkins Pipelines - Development
:source-highlighter: rouge
:toc: macro
:toclevels: 1

== Learning Objectives

By the end of this section, you will:

* **Understand** how organizations preserve Jenkins investments while gaining modern self-service capabilities
* **Create** a new secure Quarkus application using Jenkins pipeline templates
* **Experience** self-service development that reduces setup time from weeks to minutes
* **Learn** how security is automatically integrated into Jenkins workflows
* **See** how existing Jenkins expertise becomes more valuable with enhanced capabilities

== Your Jenkins Development Challenge

As a developer joining a team with significant Jenkins investments, you're facing familiar enterprise development challenges while working with trusted Jenkins infrastructure:

=== Your Current Jenkins Reality: Weeks of Setup

The process for configuring a Jenkins pipeline is often slow and inefficient. It can take one to two weeks to get a pipeline from the DevOps team, which requires multiple meetings to clarify requirements. Furthermore, security is frequently handled by custom Groovy scripts that are prone to breaking during Jenkins updates. This approach lacks standardization, resulting in unique pipeline configurations for each project and preventing code reuse.

=== What This Really Costs Your Team

- Platform team: 40 hours per new app (setup + troubleshooting)
- Security integration: +2 weeks per project
- You: More time in meetings than coding
- Microservices adoption: Blocked by Jenkins setup overhead

=== Your New Reality with RHADS: Enhanced Jenkins Self-Service

- Setup time: 1-2 weeks → 5 minutes (click template, fill form, done)
- Coordination: Multiple meetings → Zero (self-service portal)
- Security: Custom scripts → Shared `rhtap` library (maintained centrally)
- Standards: Every project different → Every project from same template

image::tekton-dev-aiimage-1.png

=== What This Means for Your Daily Jenkins Work

* Jenkins pipeline creation time: 1-2 weeks → 5 minutes
* Pipeline configuration: Manual coordination → Self-service automation with Jenkins expertise
* Security compliance: 100% consistent without becoming a Jenkins security expert
* Your productivity: Immediate access to enhanced Jenkins capabilities

IMPORTANT: Today you'll experience how organizations can transform their Jenkins investment from a bottleneck into a competitive advantage, creating production-ready Jenkins applications in minutes while preserving valuable team expertise.

== Activity 1: Accessing Your Enhanced Jenkins Environment

Let's begin your journey by logging into your modernized development environment that preserves your Jenkins workflows while adding powerful self-service capabilities.

=== Step 1: Open Red Hat Developer Hub

* Navigate to the Red Hat Developer Hub, which now provides self-service Jenkins capabilities:
+
link:{rhdh_url}[*Red Hat Developer Hub*^]

* You see the "Select a sign-in method" screen and click the *OIDC* option

image::jenkins-dev-1.png[link=self, window=_blank]

TIP: This secure authentication integration will streamline your Jenkins workflow access and eliminate multiple login prompts.

=== Step 2: Enter Your Credentials

* You're presented with the authentication form
* Enter your lab credentials:
+
[source,bash,subs="attributes"]
----
Username: {rhdh_user}
Password: {rhdh_user_password}
----

* Click the *Sign In* button to proceed

=== What You Just Discovered

You've just accessed your organization's **Internal Developer Portal (IDP)**, and it's specifically designed to enhance your Jenkins capabilities while preserving the workflows you know. The portal provides self-service Jenkins pipeline templates that eliminate waiting for platform teams to configure things manually. Jenkins resources integrate seamlessly and "just work" with security built-in from the start. Automated pipeline creation handles all the complex security integration that used to require coordination meetings and custom scripting. The streamlined onboarding experience makes your existing Jenkins expertise more valuable rather than obsolete.

"This will transform how we work with Jenkins," you realize as you explore the enhanced interface.

== Activity 2: Creating Your First Self-Service Jenkins Application

Now comes the exciting part - you're about to experience the magic of self-service Jenkins application creation that preserves your Jenkins expertise while adding modern capabilities!

=== Step 1: Discovering Jenkins Software Templates

* Ready to leverage your Jenkins skills on a new project, you spot the **+ Self-service** button in the top-right corner
* You click **+ Self-service** and discover a catalog of ready-to-use Jenkins templates

image::jenkins-dev-2.png[link=self, window=_blank]

=== Step 2: Choosing Your Jenkins Pipeline Template

* As you browse through the available templates, one immediately catches your attention:
+
`*Securing a Quarkus Service Software Supply Chain (Jenkins)*`

* "Perfect!" you think, "This leverages Jenkins - the tool I know and trust - but with modern security capabilities"
* You click *Choose* to select this Jenkins template

image::jenkins-dev-3.png[link=self, window=_blank]

TIP: You're about to witness something powerful - this single template will automatically create your complete Jenkins environment with pipelines, security integration, and Kubernetes resources* No tickets, no waiting, no manual Jenkins configuration!

=== Step 3: Configure Your Jenkins Application

The template form guides you through three key configuration sections. Each section captures the essential information needed to generate your complete Jenkins environment automatically.

==== Application Information

Ensure that the following values are set for your Jenkins application:

[cols="1,2", options="header", subs="attributes"]
|===
| Field | Default Value
| Name | `qrks-jnk-{user}`
| Group ID | `redhat.rhdh`
| Artifact ID | `qrks-jnk-{user}`
| Java Package Name | `org.redhat.rhdh`
| Description | `A cool Quarkus app with Jenkins`
|===

Click *Next* to continue.

==== Image Registry Information

These settings determine where your Jenkins pipeline will store container images:

[cols="1,2", options="header"]
|===
| Field | Default Value
| Image Registry | `Quay`
| Organization | `tssc`
|===

Click *Next* to continue.

==== Repository Information

This configures your Jenkins integration with source control:

[cols="1,2", options="header"]
|===
| Field | Default Value
| Source Repo | `GitLab`
| Repo Owner | `development`
| Verify Commits | `enabled`
|===

Note that **Verify Commits** is enabled - this ensures Jenkins pipelines include cryptographic commit signing for enterprise security.

Click *Review* to see a summary of your Jenkins configuration.

=== Step 4: Create Your Jenkins Application

* Review all the settings in the summary page

image::jenkins-dev-5.png[link=self, window=_blank]

* Click *Create* to generate your Jenkins application

The Jenkins software template will now:

* Create GitLab repositories for your source code and GitOps manifests
* Set up Jenkins pipelines with automated security scanning and signing
* Configure Kubernetes resources for your application
* Set up container image signing and verification in Jenkins workflows
* Deploy the Jenkins pipeline infrastructure and trigger the initial build

TIP: This entire Jenkins setup that traditionally takes weeks is completed in under a minute while preserving familiar Jenkins workflows!

=== Step 5: Access Your New Jenkins Component

* Once the template execution completes, click *Open Component in Catalog*

* In Red Hat Developer Hub, go to the *Catalog* and locate your new component (`qrks-jnk-{user}`)

image::jenkins-dev-6.png[link=self, window=_blank]

* Click the component name to open its *Overview* page

image::jenkins-dev-7.png[link=self, window=_blank]

* You'll see your new Jenkins application component with links to:
  * Source code repository with Jenkins pipeline definitions
  * Jenkins CI/CD pipelines and build status
  * Application overview and health monitoring
  * OpenShift Dev Spaces development environment

== Activity 3: Understanding Your Generated Jenkins Environment

=== Step 1: Exploring the Jenkins Pipeline Structure

The template you just used created a sophisticated Jenkins environment that spans multiple repositories, each serving a specific purpose in the development workflow.

The **Developer Hub Configuration Repository** contains the template definitions that power self-service. This repository holds the Jenkins template you just used, defining how new applications are structured and what resources they need. It provides the blueprint that transforms your simple form inputs into a complete Jenkins environment with security integration.

Your **Generated Application Repository** lives at `{gitlab_url}/development/qrks-jnk-{user}[^]` and contains everything needed for your application. It includes your source code, containerization configuration, and most importantly, multiple Jenkins pipeline files configured to trigger automatically based on different Git events:

**Jenkins Pipeline Structure in Your Repository**

Your Jenkins application repository contains three Jenkinsfile variants that trigger automatically based on Git events:

[cols="2,2,4"]
|===
| File | Trigger | Purpose

| `Jenkinsfile.push`
| `git push`
| Development pipeline: build → test → scan → sign → deploy to dev

| `Jenkinsfile.tag`
| `git tag v1.0 && git push --tags`
| Staging pipeline: validate with Enterprise Contract → deploy to stage

| `Jenkinsfile.release`
| Create GitLab Release
| Production pipeline: final validation → deploy to prod
|===

GitLab webhooks detect these Git events and trigger the corresponding Jenkins job automatically.

Each pipeline automatically includes comprehensive security features that would traditionally require weeks of manual configuration. Cryptographic commit verification ensures code provenance, while image signing provides artifact integrity. Enterprise Contract policy enforcement validates compliance before deployment, and Software Bill of Materials (SBOM) generation creates transparency into your dependencies. Red Hat Advanced Cluster Security scanning continuously checks for vulnerabilities throughout the pipeline.

**Reusable Jenkins Library Functions**

Your Jenkins pipelines call functions from the `rhtap` (Red Hat Trusted Application Pipeline) shared library. These functions handle security operations so you don't write custom scripts per project.

**Container build and sign:**
[cols="1,3"]
|===
| Function | What it does

| `buildah_rhtap()`
| Builds OCI container image using Buildah. Pushes to Quay registry. Returns image digest.

| `cosign_sign_attest()`
| Signs image with Sigstore/Cosign. Creates SLSA provenance attestation. Stores signature in Quay alongside image.
|===

**Security scanning:**
[cols="1,3"]
|===
| Function | What it does

| `acs_image_scan()`
| Scans image for CVEs using Red Hat Advanced Cluster Security. Fails build if critical vulnerabilities found.

| `acs_image_check()`
| Checks image against deployment policies (no root user, required labels, etc.). Fails if violations found.

| `acs_deploy_check()`
| Validates Kubernetes manifests before deployment. Checks for security misconfigurations.
|===

**Deployment and reporting:**
[cols="1,3"]
|===
| Function | What it does

| `update_deployment()`
| Updates image tag in GitOps repo (e.g., `overlays/dev/deployment-patch.yaml`). Commits and pushes change. ArgoCD detects update and syncs.

| `show_sbom_rhdh()`
| Uploads SBOM to Developer Hub for visibility into dependencies.

| `summary()`
| Generates build summary showing: image built, scans passed, policies validated.
|===

**Why this matters:** Platform team maintains the `rhtap` library. When they improve security scanning or fix bugs, all projects using the library benefit automatically. No per-project updates needed.

=== Understanding Jenkins Pipelines as Code

**What is Jenkins Pipelines as Code?**

Your Jenkins pipeline definition lives alongside your application code in the same Git repository* This approach provides:

* **Version Control**: Jenkins pipeline changes are tracked with your code changes
* **Reproducibility**: Anyone can see exactly how your application is built in Jenkins
* **Consistency**: The same Jenkins pipeline runs regardless of environment
* **Developer Ownership**: You control your Jenkins pipeline without platform team dependencies

**Why This Matters for Your Jenkins Work:**

This Pipelines as Code approach transforms how you work with Jenkins while preserving what you know. You continue using familiar Jenkins Blue Ocean interfaces and troubleshooting approaches, so there's no steep learning curve. Your Jenkins expertise gains value as it expands to include modern security and GitOps features. You gain self-service power to modify pipelines through pull requests rather than filing platform tickets and waiting. Perhaps most importantly, all the complex security integration happens automatically within your Jenkins workflows, providing enterprise-grade protection without manual configuration.

== Activity 4: Making Your First Code Change

Time to trigger your enhanced Jenkins pipeline and see the automation in action!

=== Step 1: Accessing Your Development Environment

* In your component overview, you notice a link for *OpenShift Dev Spaces* and click it
* "A browser-based development environment integrated with Jenkins?" you wonder

* If prompted for authentication, click *Log in with OpenShift*

image::jenkins-dev-8.png[link=self, window=_blank]

* On the *Authorize Access* screen, click *Allow selected permissions*

image::jenkins-dev-9.png[link=self, window=_blank]

* On the repository trust prompt, click the checkbox and then click *Continue*

image::jenkins-dev-10.png[link=self, window=_blank]

* When prompted to authenticate with GitLab, enter your credentials:
+
[source,bash,subs="attributes"]
----
Username: {gitlab_user}
Password: {gitlab_user_password}
----

image::jenkins-dev-11.png[link=self, window=_blank]

* Click *Authorize devspaces* on the next window

image::jenkins-dev-12.png[link=self, window=_blank]

* Wait for the workspace to start and fully load VS Code
* If prompted, trust all workspaces and authors

image::jenkins-dev-13.png[link=self, window=_blank]

=== Step 2: Explore Your Jenkins-Integrated Development Environment

Once your workspace loads, you'll see a complete development environment ready for immediate use. The pre-configured Quarkus project follows Jenkins best practices that your platform team has refined over years. The Jenkins pipeline definition in the `Jenkinsfile` shows your complete automated workflow, making the entire build process transparent and modifiable. Kubernetes manifests are already optimized for Jenkins-based deployments, and security configuration integrates seamlessly with your Jenkins pipeline without requiring manual setup.

=== Step 3: Making Your First Code Change

Let's trigger your enhanced Jenkins pipeline:

* You expand the `docs` folder in the file explorer
* You open the `index.md` file to document your Jenkins-powered setup
* You add this line at the end of the document:
+
[source,markdown]
----
This application uses Jenkins pipelines with enterprise security integration.
----

* You save the file (Ctrl+S or Cmd+S)

=== Step 4: Your First Signed Commit for Jenkins

* You open a terminal in Dev Spaces (*Terminal → New Terminal*)
* You stage your changes:
+
[source,bash]
----
git add .
----

* You commit your changes:
+
[source,bash]
----
git commit -m "Add Jenkins pipeline documentation"
----
+
image::jenkins-dev-15.png[link=self, window=_blank]

**What's happening now?** You're prompted for signed commit authentication. The terminal shows a URL - this is an OAuth flow to verify your identity.

**Why?** Your organization requires cryptographic proof of who made each commit.

**Who's signing?** You are using **gitsign** and **Red Hat Trusted Artifact Signer** (based on Sigstore).

**Jenkins Integration:** Your Jenkins pipeline will verify this signature as part of its security checks.

Next steps:

* You click the URL directly in the terminal, or copy and paste it into a new browser window
* If prompted for credentials, you enter your RHDH credentials to prove your identity:
+
[source,bash,subs="attributes"]
----
Username: {rhdh_user}
Password: {rhdh_user_password}
----

* Once successfully authenticated in the browser, a verification code appears on the screen
+
image::jenkins-dev-16.png[link=self, window=_blank]

* You copy this verification code from the browser
* You return to the terminal and paste the verification code when prompted
* **Result:** Your commit now has unforgeable cryptographic proof it came from you

* You push your changes to trigger your Jenkins pipeline:
+
[source,bash]
----
git push
----

[TIP]
====
**What You Just Did: Supply Chain Security in Jenkins**

Traditional Git commits can be forged - anyone can pretend to be you by setting `git config user.name "YourName"`. Your signed commit is different:

✓ **Proves your verified identity** made this change
✓ **Can't be tampered with or forged** by attackers
✓ **Provides audit trails** for compliance (SOC 2, PCI)
✓ **Integrates with Jenkins** for automated verification in your pipeline

**The Technical Flow:**

1. You ran `git commit` → Git invoked **gitsign**
2. Gitsign requested authentication → Browser OAuth flow opened
3. You verified your identity → **Sigstore** issued a short-lived certificate
4. The commit was signed → Cryptographic signature attached to commit
5. The signature was pushed → Your Jenkins pipeline can verify it automatically

**Jenkins Enhancement:**

Your Jenkins pipeline includes a `verify-commit` stage that checks this signature. This ensures only verified, signed commits progress through your pipeline - adding enterprise security without slowing down your familiar Jenkins workflow.

This 30-second authentication protects your code, your team, and your customers while triggering your enhanced Jenkins pipeline with automated security scanning and deployment!
====

image::jenkins-dev-17.png[link=self, window=_blank]

== Activity 5: Monitoring Your Jenkins Pipeline

Now let's see your enhanced Jenkins pipeline in action and understand what's happening behind the scenes.

=== Step 1: Access Jenkins Pipeline Execution

* Navigate back to Developer Hub
* Go to the *CI* tab of your `qrks-jnk-{user}` component
* You should see your Jenkins pipeline runs:
  - `maven-ci-build`
  - `promote-to-stage`
  - `promote-to-prod`

image::jenkins-dev-18.png[link=self, window=_blank]

* Click on *View build* to open Jenkins
* Click *Open Blue Ocean* to view the Jenkins pipeline visually

image::jenkins-dev-19.png[link=self, window=_blank]

=== Step 2: Understanding Your Jenkins Pipeline Stages

As your Jenkins pipeline executes, you can observe each stage in the familiar Blue Ocean interface:

image::jenkins-dev-20.png[link=self, window=_blank]

**Stage: verify-commit**

* Verifies that your Git commit was cryptographically signed using `gitsign`
* Downloads and uses the gitsign client to verify commit signatures
* Integrates with Red Hat Trusted Application Signer (RHTAS) via Rekor and TUF
* Ensures the commit came from a trusted developer identity
* This enterprise security happens automatically in your Jenkins workflow

**Stage: mvn package**

* Runs `mvn clean package` in a dedicated Maven container
* Compiles and packages your Quarkus application
* Produces the runnable JAR for container image creation
* Uses Maven 3.8.6 with OpenJDK 11 for consistent builds

**Stage: init**

* Prepares the Jenkins build environment using the `rhtap` library
* Sets IMAGE_URL with the Git commit as the tag
* Generates ISO timestamp for effective time tracking
* Initializes the RHTAP shared library functions
* Standardizes behavior across all Jenkins pipelines

**Stage: build**

* Uses `buildah_rhtap()` function to containerize your application
* Automatically signs the image and creates attestations using `cosign_sign_attest()`
* Generates provenance metadata and SLSA attestations for supply chain security
* Captures the image digest for downstream pipeline stages
* All security integration happens transparently in Jenkins

**Stage: deploy-and-upload-to-tpa (parallel)**

* *deploy*: Uses `update_deployment()` to update GitOps repository with new image tag
* *upload_sbom_to_trustification*: Processes and uploads SBOM files to Trustification
  - Updates SBOM component name to match the application
  - Removes non-CycloneDX JSON files from the SBOM directory
  - Pushes Software Bill of Materials to Red Hat Trusted Profile Analyzer
* No manual coordination required between Jenkins and deployment teams

**Stage: acs (parallel)**

* *acs_deploy_check*: Verifies Kubernetes manifests for security compliance
* *acs_image_check*: Enforces policy on container image configuration
* *acs_image_scan*: Performs vulnerability scanning using Red Hat Advanced Cluster Security
* All security validation integrated into your Jenkins workflow

**Stage: summary**

* Executes `show_sbom_rhdh()` to display SBOM information for Developer Hub integration
* Runs `summary()` function to provide comprehensive build status and artifacts
* Shows build status and key artifacts (SBOM, scan summary, security results)
* Provides comprehensive build information in familiar Jenkins interface
* Uses reusable functions from the `rhtap` library

=== Step 3: Exploring the Jenkins Pipeline Definition

* In your GitLab repository, open the `Jenkinsfile` in the root directory
* Notice how this *Pipelines as Code* approach gives you:
  - CI logic living alongside your application code
  - Easy updates via pull requests
  - Version-controlled pipeline definitions
  - Full transparency into the Jenkins build process

## What You Just Accomplished

Congratulations! You've experienced a fundamental transformation in how Jenkins works in your organization.

The time savings are dramatic and immediate. Traditional Jenkins setup requires 1-2 weeks of manual pipeline configuration, coordination meetings, and back-and-forth with platform teams. The RHADS Jenkins approach delivers the same result in less than 5 minutes through self-service, with enhanced security that would take weeks to configure manually.

Security becomes a built-in feature rather than a bolt-on afterthought. Your Jenkins application now includes automated container vulnerability scanning that runs with every build. Image signing and verification integrate seamlessly with Jenkins pipelines, providing cryptographic proof of artifact integrity. Enterprise security policies enforce automatically without manual gates, and complete audit trails generate through Jenkins processes rather than requiring separate compliance tools.

Most importantly, everything you've built leverages and enhances your existing Jenkins knowledge rather than replacing it. You're using the familiar Jenkins Blue Ocean interface with enhanced capabilities layered on top. The pipeline concepts remain the same, just augmented with modern security integration. Your Jenkins expertise becomes more valuable as it expands to include these modern practices. The proven Jenkins infrastructure your organization has invested in gets enhanced rather than replaced.

== What You Built: Jenkins Pipelines with Modern Security

You just triggered a Jenkins pipeline that most organizations would spend weeks configuring. Let's connect what you experienced to how this architecture works in production.

**Jenkins shared library you're using:**

Your `Jenkinsfile.push` calls functions from the `rhtap` shared library (`@Library('rhtap')_`). This library lives in a separate Git repository that your Jenkins controller loads dynamically. When you ran `buildah_rhtap()`, Jenkins executed containerized Buildah inside a Kubernetes pod, not on a traditional Jenkins agent. The `cosign_sign_attest()` function communicated with Red Hat Trusted Artifact Signer to sign your image without you needing to manage signing keys. Platform team updates the library once; all projects using it get the improvements automatically.

**GitLab webhook triggering your pipeline:**

When you pushed your commit, GitLab sent a webhook POST request to Jenkins with the commit SHA and branch name. Jenkins matched this to your `maven-ci-build` job configuration and triggered the build. The job pulled your repository, parsed `Jenkinsfile.push`, and executed each stage. Three Jenkinsfiles (`Jenkinsfile.push`, `Jenkinsfile.tag`, `Jenkinsfile.release`) handle different Git events—push, tag, release—all configured automatically by the Developer Hub template.

**Jenkins running on Kubernetes:**

Your Jenkins controller runs as a pod in the OpenShift cluster. Each pipeline stage executes in ephemeral Kubernetes pods that terminate when the stage completes. This differs from traditional Jenkins agents that run continuously. The `mvn package` stage ran in a Maven container, `buildah_rhtap()` ran in a Buildah container, and `acs_image_scan()` ran in an ACS CLI container. No agent configuration, no "node is offline" debugging—just container images defined in your Jenkinsfile.

**GitOps integration from Jenkins:**

The `update_deployment()` function in your pipeline clones your GitOps repository, updates `overlays/dev/deployment-patch.yaml` with the new image tag, commits the change, and pushes it back to GitLab. ArgoCD polls your GitOps repository every 3 minutes, detects the Git change, and applies the updated Deployment manifest to your cluster. Jenkins never runs `kubectl apply` directly—it just updates Git, and ArgoCD handles deployment reconciliation.

**Enterprise Contract validation you'll see next:**

When you create a Git tag in the staging section, your `Jenkinsfile.tag` pipeline will call Enterprise Contract CLI to verify your image signature, SBOM, and CVE scan results before promotion. This validation runs in Jenkins as another pipeline stage. If validation fails (e.g., critical CVE found), the Jenkins build fails and the image doesn't get promoted. Policy-as-code enforcement without manual security reviews.

== Next Steps

In the next section, **Staging - Jenkins Pipeline Promotion**, you'll:

* Experience Jenkins-based staging promotion using familiar tools
* Learn how Git tags trigger Jenkins staging pipelines automatically
* See how Enterprise Contract validation integrates with Jenkins workflows
* Understand GitOps deployment through Jenkins pipeline automation

Your enhanced Jenkins foundation is now in place - let's see your staging promotion in action!


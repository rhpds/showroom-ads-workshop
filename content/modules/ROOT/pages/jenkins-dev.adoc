= Jenkins Pipelines - Development
:source-highlighter: rouge
:toc: macro
:toclevels: 1

== Learning Objectives

By the end of this section, you will:

* **Understand** how organizations preserve Jenkins investments while gaining modern self-service capabilities
* **Create** a new secure Quarkus application using Jenkins pipeline templates
* **Experience** self-service development that reduces setup time from weeks to minutes
* **Learn** how security is automatically integrated into Jenkins workflows
* **See** how existing Jenkins expertise becomes more valuable with enhanced capabilities

== Your Jenkins Development Challenge

As a developer joining a team with significant Jenkins investments, you're facing familiar enterprise development challenges while working with trusted Jenkins infrastructure:

=== Your Current Jenkins Reality: Weeks of Setup

1-2 weeks waiting for DevOps to configure your Jenkins pipeline. Multiple meetings to explain requirements. When security finally gets added, it's custom Groovy scripts that break when Jenkins updates. Each project's pipeline configured slightly differently‚Äîno standards, no reuse.

=== What This Really Costs Your Team

- Platform team: 40 hours per new app (setup + troubleshooting)
- Security integration: +2 weeks per project
- You: More time in meetings than coding
- Microservices adoption: Blocked by Jenkins setup overhead

=== Your New Reality with RHADS: Enhanced Jenkins Self-Service

- Setup time: 1-2 weeks ‚Üí 5 minutes (click template, fill form, done)
- Coordination: Multiple meetings ‚Üí Zero (self-service portal)
- Security: Custom scripts ‚Üí Shared `rhtap` library (maintained centrally)
- Standards: Every project different ‚Üí Every project from same template

=== What This Means for Your Daily Jenkins Work

* Jenkins pipeline creation time: 1-2 weeks ‚Üí 5 minutes
* Pipeline configuration: Manual coordination ‚Üí Self-service automation with Jenkins expertise
* Security compliance: 100% consistent without becoming a Jenkins security expert
* Your productivity: Immediate access to enhanced Jenkins capabilities

IMPORTANT: Today you'll experience how organizations can transform their Jenkins investment from a bottleneck into a competitive advantage, creating production-ready Jenkins applications in minutes while preserving valuable team expertise.

== Activity 1: Accessing Your Enhanced Jenkins Environment

Let's begin your journey by logging into your modernized development environment that preserves your Jenkins workflows while adding powerful self-service capabilities.

=== Step 1: Open Red Hat Developer Hub

* Navigate to the Red Hat Developer Hub, which now provides self-service Jenkins capabilities:
+
link:{rhdh_url}[*Red Hat Developer Hub*^]

* You see the "Select a sign-in method" screen and click the *OIDC* option

image::jenkins-dev-1.png[]

TIP: This secure authentication integration will streamline your Jenkins workflow access and eliminate multiple login prompts.

=== Step 2: Enter Your Credentials

* You're presented with the authentication form
* Enter your lab credentials:
+
[source,bash,subs="attributes"]
----
Username: {rhdh_user}
Password: {rhdh_user_password}
----

* Click the *Sign In* button to proceed

=== What You Just Discovered

You've just accessed your organization's **Internal Developer Portal (IDP)**, and it's specifically designed to enhance your Jenkins capabilities while preserving the workflows you know. The portal provides self-service Jenkins pipeline templates that eliminate waiting for platform teams to configure things manually. Jenkins resources integrate seamlessly and "just work" with security built-in from the start. Automated pipeline creation handles all the complex security integration that used to require coordination meetings and custom scripting. The streamlined onboarding experience makes your existing Jenkins expertise more valuable rather than obsolete.

"This will transform how we work with Jenkins," you realize as you explore the enhanced interface.

== Activity 2: Creating Your First Self-Service Jenkins Application

Now comes the exciting part - you're about to experience the magic of self-service Jenkins application creation that preserves your Jenkins expertise while adding modern capabilities!

=== Step 1: Discovering Jenkins Software Templates

* Ready to leverage your Jenkins skills on a new project, you spot the **+ Self-service** button in the top-right corner
* You click **+ Self-service** and discover a catalog of ready-to-use Jenkins templates

image::jenkins-dev-2.png[]

=== Step 2: Choosing Your Jenkins Pipeline Template

* As you browse through the available templates, one immediately catches your attention:
+
`*Securing a Quarkus Service Software Supply Chain (Jenkins)*`

* "Perfect!" you think, "This leverages Jenkins - the tool I know and trust - but with modern security capabilities"
* You click *Choose* to select this Jenkins template

image::jenkins-dev-3.png[]

TIP: You're about to witness something powerful - this single template will automatically create your complete Jenkins environment with pipelines, security integration, and Kubernetes resources* No tickets, no waiting, no manual Jenkins configuration!

=== Step 3: Configure Your Jenkins Application

The template form guides you through three key configuration sections. Each section captures the essential information needed to generate your complete Jenkins environment automatically.

==== Application Information

Ensure that the following values are set for your Jenkins application:

[cols="1,2", options="header", subs="attributes"]
|===
| Field | Default Value
| Name | `qrks-jnk-{user}`
| Group ID | `redhat.rhdh`
| Artifact ID | `qrks-jnk-{user}`
| Java Package Name | `org.redhat.rhdh`
| Description | `A cool Quarkus app with Jenkins`
|===

Click *Next* to continue.

==== Image Registry Information

These settings determine where your Jenkins pipeline will store container images:

[cols="1,2", options="header"]
|===
| Field | Default Value
| Image Registry | `Quay`
| Organization | `tssc`
|===

Click *Next* to continue.

==== Repository Information

This configures your Jenkins integration with source control:

[cols="1,2", options="header"]
|===
| Field | Default Value
| Source Repo | `GitLab`
| Repo Owner | `development`
| Verify Commits | `enabled`
|===

Note that **Verify Commits** is enabled - this ensures Jenkins pipelines include cryptographic commit signing for enterprise security.

Click *Review* to see a summary of your Jenkins configuration.

=== Step 4: Create Your Jenkins Application

* Review all the settings in the summary page

image::jenkins-dev-5.png[]

* Click *Create* to generate your Jenkins application

The Jenkins software template will now:

* Create GitLab repositories for your source code and GitOps manifests
* Set up Jenkins pipelines with automated security scanning and signing
* Configure Kubernetes resources for your application
* Set up container image signing and verification in Jenkins workflows
* Deploy the Jenkins pipeline infrastructure and trigger the initial build

TIP: This entire Jenkins setup that traditionally takes weeks is completed in under a minute while preserving familiar Jenkins workflows!

=== Step 5: Access Your New Jenkins Component

* Once the template execution completes, click *Open Component in Catalog*

* In Red Hat Developer Hub, go to the *Catalog* and locate your new component (`qrks-jnk-{user}`)

image::jenkins-dev-6.png[]

* Click the component name to open its *Overview* page

image::jenkins-dev-7.png[]

* You'll see your new Jenkins application component with links to:
  * Source code repository with Jenkins pipeline definitions
  * Jenkins CI/CD pipelines and build status
  * Application overview and health monitoring
  * OpenShift Dev Spaces development environment

== Activity 3: Understanding Your Generated Jenkins Environment

=== Step 1: Exploring the Jenkins Pipeline Structure

The template you just used created a sophisticated Jenkins environment that spans multiple repositories, each serving a specific purpose in the development workflow.

The **Developer Hub Configuration Repository** contains the template definitions that power self-service. This repository holds the Jenkins template you just used, defining how new applications are structured and what resources they need. It provides the blueprint that transforms your simple form inputs into a complete Jenkins environment with security integration.

Your **Generated Application Repository** lives at `{gitlab_url}/development/qrks-jnk-{user}[^]` and contains everything needed for your application. It includes your source code, containerization configuration, and most importantly, multiple Jenkins pipeline files configured to trigger automatically based on different Git events:

**Jenkins Pipeline Structure in Your Repository**

Your Jenkins application repository contains three Jenkinsfile variants that trigger automatically based on Git events:

[cols="2,2,4"]
|===
| File | Trigger | Purpose

| `Jenkinsfile.push`
| `git push`
| Development pipeline: build ‚Üí test ‚Üí scan ‚Üí sign ‚Üí deploy to dev

| `Jenkinsfile.tag`
| `git tag v1.0 && git push --tags`
| Staging pipeline: validate with Enterprise Contract ‚Üí deploy to stage

| `Jenkinsfile.release`
| Create GitLab Release
| Production pipeline: final validation ‚Üí deploy to prod
|===

GitLab webhooks detect these Git events and trigger the corresponding Jenkins job automatically.

Each pipeline automatically includes comprehensive security features that would traditionally require weeks of manual configuration. Cryptographic commit verification ensures code provenance, while image signing provides artifact integrity. Enterprise Contract policy enforcement validates compliance before deployment, and Software Bill of Materials (SBOM) generation creates transparency into your dependencies. Red Hat Advanced Cluster Security scanning continuously checks for vulnerabilities throughout the pipeline.

**Reusable Jenkins Library Functions**

Your Jenkins pipelines call functions from the `rhtap` (Red Hat Trusted Application Pipeline) shared library. These functions handle security operations so you don't write custom scripts per project.

**Container build and sign:**
[cols="1,3"]
|===
| Function | What it does

| `buildah_rhtap()`
| Builds OCI container image using Buildah. Pushes to Quay registry. Returns image digest.

| `cosign_sign_attest()`
| Signs image with Sigstore/Cosign. Creates SLSA provenance attestation. Stores signature in Quay alongside image.
|===

**Security scanning:**
[cols="1,3"]
|===
| Function | What it does

| `acs_image_scan()`
| Scans image for CVEs using Red Hat Advanced Cluster Security. Fails build if critical vulnerabilities found.

| `acs_image_check()`
| Checks image against deployment policies (no root user, required labels, etc.). Fails if violations found.

| `acs_deploy_check()`
| Validates Kubernetes manifests before deployment. Checks for security misconfigurations.
|===

**Deployment and reporting:**
[cols="1,3"]
|===
| Function | What it does

| `update_deployment()`
| Updates image tag in GitOps repo (e.g., `overlays/dev/deployment-patch.yaml`). Commits and pushes change. ArgoCD detects update and syncs.

| `show_sbom_rhdh()`
| Uploads SBOM to Developer Hub for visibility into dependencies.

| `summary()`
| Generates build summary showing: image built, scans passed, policies validated.
|===

**Why this matters:** Platform team maintains the `rhtap` library. When they improve security scanning or fix bugs, all projects using the library benefit automatically. No per-project updates needed.

=== Understanding Jenkins Pipelines as Code

**What is Jenkins Pipelines as Code?**

Your Jenkins pipeline definition lives alongside your application code in the same Git repository* This approach provides:

* **Version Control**: Jenkins pipeline changes are tracked with your code changes
* **Reproducibility**: Anyone can see exactly how your application is built in Jenkins
* **Consistency**: The same Jenkins pipeline runs regardless of environment
* **Developer Ownership**: You control your Jenkins pipeline without platform team dependencies

**Your Jenkins Pipeline Stages:**

**üîç `verify-commit`**
```groovy
// Verifies cryptographic commit signatures using gitsign
// Downloads gitsign client and verifies commit signatures
// Integrates with Red Hat Trusted Application Signer via TUF and Rekor
```

**Jenkinsfile.push stages:**

[cols="2,5"]
|===
| Stage | What it does

| `init`
| Initializes `rhtap` library. Sets `IMAGE_URL` with Git commit as tag. Prepares build environment.

| `mvn package`
| Runs `mvn clean package` in Maven 3.8.6 container. Compiles Quarkus application to JAR.

| `build`
| Calls `buildah_rhtap()` to build container image. Calls `cosign_sign_attest()` to sign image and create SLSA provenance.

| `deploy` + `upload_sbom` (parallel)
| **deploy:** Calls `update_deployment()` to update GitOps repo. **upload_sbom:** Sends SBOM to Trustification.

| `acs_deploy_check` + `acs_image_check` + `acs_image_scan` (parallel)
| Validates Kubernetes manifests, checks image policies, scans for CVEs using ACS.

| `summary`
| Calls `show_sbom_rhdh()` and `summary()` to display results in Developer Hub.
|===

**Why This Matters for Your Jenkins Work:**

This Pipelines as Code approach transforms how you work with Jenkins while preserving what you know. You continue using familiar Jenkins Blue Ocean interfaces and troubleshooting approaches, so there's no steep learning curve. Your Jenkins expertise gains value as it expands to include modern security and GitOps features. You gain self-service power to modify pipelines through pull requests rather than filing platform tickets and waiting. Perhaps most importantly, all the complex security integration happens automatically within your Jenkins workflows, providing enterprise-grade protection without manual configuration.

== Activity 4: Making Your First Code Change

Time to trigger your enhanced Jenkins pipeline and see the automation in action!

=== Step 1: Accessing Your Development Environment

* In your component overview, you notice a link for *OpenShift Dev Spaces* and click it
* "A browser-based development environment integrated with Jenkins?" you wonder

* If prompted for authentication, click *Log in with OpenShift*

image::jenkins-dev-8.png[]

* On the *Authorize Access* screen, click *Allow selected permissions*

image::jenkins-dev-9.png[]

* On the repository trust prompt, click the checkbox and then click *Continue*

image::jenkins-dev-10.png[]

* When prompted to authenticate with GitLab, enter your credentials:
+
[source,bash,subs="attributes"]
----
Username: {gitlab_user}
Password: {gitlab_user_password}
----

image::jenkins-dev-11.png[]

* Click *Authorize devspaces* on the next window

image::jenkins-dev-12.png[]

* Wait for the workspace to start and fully load VS Code
* If prompted, trust all workspaces and authors

image::jenkins-dev-13.png[]

=== Step 2: Explore Your Jenkins-Integrated Development Environment

Once your workspace loads, you'll see a complete development environment ready for immediate use. The pre-configured Quarkus project follows Jenkins best practices that your platform team has refined over years. The Jenkins pipeline definition in the `Jenkinsfile` shows your complete automated workflow, making the entire build process transparent and modifiable. Kubernetes manifests are already optimized for Jenkins-based deployments, and security configuration integrates seamlessly with your Jenkins pipeline without requiring manual setup.

=== Step 3: Making Your First Code Change

Let's trigger your enhanced Jenkins pipeline:

* You expand the `docs` folder in the file explorer
* You open the `index.md` file to document your Jenkins-powered setup
* You add this line at the end of the document:
+
[source,markdown]
----
This application uses Jenkins pipelines with enterprise security integration.
----

* You save the file (Ctrl+S or Cmd+S)

=== Step 4: Your First Signed Commit for Jenkins

* You open a terminal in Dev Spaces (*Terminal ‚Üí New Terminal*)
* You stage your changes:
+
[source,bash]
----
git add .
----

* You commit your changes:
+
[source,bash]
----
git commit -m "Add Jenkins pipeline documentation"
----
+
image::jenkins-dev-15.png[]

* You're prompted for signed commit authentication - this integrates with your Jenkins security workflow
* The terminal displays a URL that you need to follow for authentication
* You click the URL directly in the terminal, or copy and paste it into a new browser window
* If prompted for credentials during the browser authentication, you use your RHDH credentials:
+
[source,bash,subs="attributes"]
----
Username: {rhdh_user}
Password: {rhdh_user_password}
----

* Once successfully authenticated in the browser, a verification code appears on the screen
+
image::jenkins-dev-16.png[]

* You copy this verification code from the browser
* You return to the terminal and paste the verification code when prompted
* After entering the code, your commit is cryptographically signed for enterprise security
* You push your changes:
+
[source,bash]
----
git push
----

TIP: You just witnessed the power of enhanced Jenkins workflows - your commit triggered a complete Jenkins pipeline with enterprise security, all automatically configured and integrated!

image::jenkins-dev-17.png[]

== Activity 5: Monitoring Your Jenkins Pipeline

Now let's see your enhanced Jenkins pipeline in action and understand what's happening behind the scenes.

=== Step 1: Access Jenkins Pipeline Execution

* Navigate back to Developer Hub
* Go to the *CI* tab of your `qrks-jnk-{user}` component
* You should see your Jenkins pipeline runs:
  - `maven-ci-build`
  - `promote-to-stage`
  - `promote-to-prod`

image::jenkins-dev-18.png[]

* Click on *View build* to open Jenkins
* Click *Open Blue Ocean* to view the Jenkins pipeline visually

image::jenkins-dev-19.png[]

=== Step 2: Understanding Your Jenkins Pipeline Stages

As your Jenkins pipeline executes, you can observe each stage in the familiar Blue Ocean interface:

image::jenkins-dev-20.png[]

**Stage: verify-commit**

* Verifies that your Git commit was cryptographically signed using `gitsign`
* Downloads and uses the gitsign client to verify commit signatures
* Integrates with Red Hat Trusted Application Signer (RHTAS) via Rekor and TUF
* Ensures the commit came from a trusted developer identity
* This enterprise security happens automatically in your Jenkins workflow

**Stage: mvn package**

* Runs `mvn clean package` in a dedicated Maven container
* Compiles and packages your Quarkus application
* Produces the runnable JAR for container image creation
* Uses Maven 3.8.6 with OpenJDK 11 for consistent builds

**Stage: init**

* Prepares the Jenkins build environment using the `rhtap` library
* Sets IMAGE_URL with the Git commit as the tag
* Generates ISO timestamp for effective time tracking
* Initializes the RHTAP shared library functions
* Standardizes behavior across all Jenkins pipelines

**Stage: build**

* Uses `buildah_rhtap()` function to containerize your application
* Automatically signs the image and creates attestations using `cosign_sign_attest()`
* Generates provenance metadata and SLSA attestations for supply chain security
* Captures the image digest for downstream pipeline stages
* All security integration happens transparently in Jenkins

**Stage: deploy-and-upload-to-tpa (parallel)**

* *deploy*: Uses `update_deployment()` to update GitOps repository with new image tag
* *upload_sbom_to_trustification*: Processes and uploads SBOM files to Trustification
  - Updates SBOM component name to match the application
  - Removes non-CycloneDX JSON files from the SBOM directory
  - Pushes Software Bill of Materials to Red Hat Trusted Profile Analyzer
* No manual coordination required between Jenkins and deployment teams

**Stage: acs (parallel)**

* *acs_deploy_check*: Verifies Kubernetes manifests for security compliance
* *acs_image_check*: Enforces policy on container image configuration
* *acs_image_scan*: Performs vulnerability scanning using Red Hat Advanced Cluster Security
* All security validation integrated into your Jenkins workflow

**Stage: summary**

* Executes `show_sbom_rhdh()` to display SBOM information for Developer Hub integration
* Runs `summary()` function to provide comprehensive build status and artifacts
* Shows build status and key artifacts (SBOM, scan summary, security results)
* Provides comprehensive build information in familiar Jenkins interface
* Uses reusable functions from the `rhtap` library

=== Step 3: Exploring the Jenkins Pipeline Definition

* In your GitLab repository, open the `Jenkinsfile` in the root directory
* Notice how this *Pipelines as Code* approach gives you:
  - CI logic living alongside your application code
  - Easy updates via pull requests
  - Version-controlled pipeline definitions
  - Full transparency into the Jenkins build process

## What You Just Accomplished

Congratulations! You've experienced a fundamental transformation in how Jenkins works in your organization.

The time savings are dramatic and immediate. Traditional Jenkins setup requires 1-2 weeks of manual pipeline configuration, coordination meetings, and back-and-forth with platform teams. The RHADS Jenkins approach delivers the same result in less than 5 minutes through self-service, with enhanced security that would take weeks to configure manually.

Security becomes a built-in feature rather than a bolt-on afterthought. Your Jenkins application now includes automated container vulnerability scanning that runs with every build. Image signing and verification integrate seamlessly with Jenkins pipelines, providing cryptographic proof of artifact integrity. Enterprise security policies enforce automatically without manual gates, and complete audit trails generate through Jenkins processes rather than requiring separate compliance tools.

Most importantly, everything you've built leverages and enhances your existing Jenkins knowledge rather than replacing it. You're using the familiar Jenkins Blue Ocean interface with enhanced capabilities layered on top. The pipeline concepts remain the same, just augmented with modern security integration. Your Jenkins expertise becomes more valuable as it expands to include these modern practices. The proven Jenkins infrastructure your organization has invested in gets enhanced rather than replaced.

== Understanding Enhanced Jenkins Benefits

=== Developer Experience

The developer experience improves without sacrificing familiarity. You continue using the Jenkins Blue Ocean interface and tools you already know, so there's no productivity loss during transition. Pipeline capabilities enhance with modern security features that integrate seamlessly without adding complexity to your daily workflow. Self-service power eliminates platform team dependencies for common tasks, letting you move at your own pace. The cloud-based development environment integrates naturally with Jenkins, providing consistency between local development and CI/CD execution.

=== Operational Advantages

Operations benefit from enhanced capabilities while protecting existing investments. Your Jenkins infrastructure and the expertise you've developed remain valuable assets that gain new capabilities. Enterprise-grade security integrates automatically rather than requiring custom configurations for each project. Standardized pipelines ensure consistent workflows across all applications, reducing the cognitive overhead of context-switching between teams. Shared Jenkins libraries eliminate the custom pipeline overhead that creates maintenance burdens and knowledge silos.

=== Enterprise Security Enhancements

Security enhancements integrate transparently into your existing Jenkins workflows. Automated security scanning runs as a natural part of your builds rather than a separate manual process. Cryptographic signing for both containers and commits happens through Jenkins without developers needing to understand the underlying complexity. Enterprise security policies enforce automatically at the appropriate pipeline stages, catching issues before they reach production. Complete audit trails generate through normal Jenkins processes, providing compliance evidence without additional tools or manual documentation.

== Next Steps

In the next section, **Staging - Jenkins Pipeline Promotion**, you'll:

* Experience Jenkins-based staging promotion using familiar tools
* Learn how Git tags trigger Jenkins staging pipelines automatically
* See how Enterprise Contract validation integrates with Jenkins workflows
* Understand GitOps deployment through Jenkins pipeline automation

Your enhanced Jenkins foundation is now in place - let's see your staging promotion in action!


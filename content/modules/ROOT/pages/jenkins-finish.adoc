= Jenkins - Summary
:source-highlighter: rouge
:toc: macro
:toclevels: 2

toc::[]

== Module Completion

Congratulations! You've successfully completed the **Jenkins** module of the Red Hat Advanced Developer Suite Workshop.

This module demonstrated how RHADS enhances existing Jenkins investments while providing modern capabilities and enterprise-grade security.

== What You Built

You enhanced Jenkins with modern security capabilities while keeping the Jenkins Blue Ocean interface and Jenkinsfile syntax your team already knows.

**Jenkins shared library integration:** Your `Jenkinsfile.push` starts with `@Library('rhtap')_` which loads functions from a Git repository containing reusable security logic. When you called `buildah_rhtap()`, Jenkins executed containerized Buildah in a Kubernetes pod (not a traditional VM-based agent). The `cosign_sign_attest()` function signed your image using Red Hat Trusted Artifact Signer. The `acs_image_scan()` function ran Red Hat Advanced Cluster Security scanning. Platform team maintains one library; all projects using it get security updates automatically.

**Three Jenkinsfiles for three workflows:** `Jenkinsfile.push` (triggered by `git push`), `Jenkinsfile.tag` (triggered by `git tag`), and `Jenkinsfile.release` (triggered by GitLab Release). GitLab webhooks send POST requests to Jenkins for each event type. Jenkins matches the event to the corresponding job and executes the appropriate Jenkinsfile. This event-driven automation eliminates manual job triggering.

**GitOps deployment from Jenkins:** Your Jenkins pipeline never ran `kubectl apply`. The `update_deployment()` function cloned your GitOps repository, updated the image tag in `overlays/dev/deployment-patch.yaml`, committed the change, and pushed back to GitLab. ArgoCD detected the Git change and reconciled cluster state automatically. Jenkins has no production cluster credentials—it writes to Git, ArgoCD reads from Git.

**Enterprise Contract validation in Jenkins:** Your `Jenkinsfile.tag` pipeline calls Enterprise Contract CLI to validate image signatures, SBOMs, and CVE scan results before promoting to staging. If validation fails (critical CVE, missing signature, invalid provenance), the Jenkins build fails and the image doesn't get promoted. This is policy-as-code enforcement running as a Jenkins stage—no manual security review meetings.

**What changed from traditional Jenkins:**

Traditional Jenkins: Each project has custom Jenkinsfile with copy-pasted security scanning logic. Security tools change, you update 50 Jenkinsfiles manually. Jenkins agents run 24/7 consuming resources even when idle. Deployment requires `kubectl` credentials in Jenkins, creating security risk.

Enhanced Jenkins: Projects call `rhtap` library functions. Security logic lives in one place. Update the library, all projects benefit. Jenkins executes build stages in ephemeral Kubernetes pods that terminate when done. GitOps separation means Jenkins writes to Git (which developers can already access); cluster credentials stay with ArgoCD.

**Quantified improvements:**

- Pipeline setup: 1-2 weeks → 5 minutes (Developer Hub template generates Jenkinsfiles automatically)
- Security scanning integration: 2 weeks custom scripting → automatic (`rhtap` library includes scanning)
- Staging promotion validation: 3-5 days manual review → 30 minutes (Enterprise Contract validates automatically)
- Production deployment: Manual kubectl with VPN → GitOps (Jenkins updates Git, ArgoCD deploys)

== Key Technical Concepts

**Jenkins Shared Libraries:** The `@Library('rhtap')_` annotation in your Jenkinsfile tells Jenkins to load a Git repository containing Groovy functions. Jenkins clones this repository at the start of your pipeline and makes its functions available. The `vars/` directory contains function definitions like `buildah_rhtap.groovy`. When you call `buildah_rhtap()`, Jenkins executes the Groovy code which orchestrates Buildah container execution. This is Jenkins' mechanism for code reuse across pipelines.

**Kubernetes plugin for Jenkins:** Traditional Jenkins runs builds on dedicated VM agents. This Jenkins installation uses the Kubernetes plugin which spawns ephemeral pods for each build stage. Your `Jenkinsfile.push` has stages like `mvn package`, `build`, `acs`. Each stage specifies a container image (Maven container, Buildah container, ACS CLI container). Jenkins creates a pod with that container, executes the stage commands inside it, captures the output, and terminates the pod when the stage completes.

**GitLab webhook integration:** When you push to GitLab, GitLab sends HTTP POST to Jenkins webhook URL with payload containing commit SHA, branch name, and repository URL. Jenkins Generic Webhook Trigger plugin parses this JSON, extracts variables, and triggers the `maven-ci-build` job. The job clones your repository at the specified commit SHA and executes `Jenkinsfile.push`. Similarly, Git tags trigger `promote-to-stage` job, and GitLab Releases trigger `promote-to-prod` job.

**Jenkins credential management:** Your `rhtap` library functions need to authenticate to Quay registry (push images), GitLab (update GitOps repo), and Red Hat Trusted Artifact Signer (sign images). These credentials are stored as Jenkins Credentials objects. The shared library references them by credential ID: `withCredentials([usernamePassword(credentialsId: 'quay-creds', ...)])`. This centralizes secret management—update credential once in Jenkins, all pipelines using it get the updated secret.

== When to Use This Approach

**Enhanced Jenkins fits when:**

You have substantial existing Jenkins infrastructure—dedicated Jenkins controllers, hundreds of existing pipelines, operational procedures, and team expertise built over years. Migration to Tekton would require rewriting all Jenkinsfiles from Groovy to YAML, retraining teams, and disrupting production deployments. The Jenkins+RHADS approach preserves this investment while adding modern security capabilities through the `rhtap` shared library.

Your team knows Jenkins Pipelines as Code (declarative or scripted), Jenkins Blue Ocean for monitoring, and Jenkins credential management. Learning `kubectl` and Tekton YAML would slow them down. They can immediately understand `buildah_rhtap()` and `acs_image_scan()` function calls in familiar Jenkinsfile syntax.

You need gradual adoption. New projects use Developer Hub templates that generate Jenkinsfiles with `@Library('rhtap')_`. Existing projects continue with current Jenkinsfiles. Over time, existing projects add `@Library('rhtap')_` and migrate to shared library functions incrementally—one stage at a time, one pipeline at a time. No "big bang" migration.

**Enhanced Jenkins might not fit when:**

You're building greenfield microservices on Kubernetes with no existing Jenkins infrastructure. Standing up Jenkins controllers, configuring Kubernetes plugin, and managing shared libraries adds complexity. Tekton pipelines that run as pods with no server to maintain would be simpler.

Your Jenkins environment has technical debt—outdated plugins, unsupported configurations, custom Groovy scripting that nobody understands. "Enhancing" this might preserve problems. Consider fresh start with Tekton, or Jenkins upgrade project before RHADS integration.

You want to eliminate Jenkins entirely for cost reasons (Jenkins controller maintenance, plugin updates, Java version upgrades). The Jenkins+RHADS approach enhances Jenkins, doesn't replace it. You still maintain Jenkins infrastructure.

== Next Steps

**Explore the Tekton module** to compare approaches. You'll see how the same RHADS security capabilities (Enterprise Contract, image signing, SBOM generation, GitOps) work with Kubernetes-native Tekton pipelines instead of Jenkins. Same security guarantees, different execution engine. This helps you decide: enhance existing Jenkins, or migrate to Tekton for new projects.

**Customize the `rhtap` shared library** for your organization's needs. Clone the library repository, add functions for your specific tools (your vulnerability scanner, your artifact repository, your deployment target). Platform team maintains the library; all teams using it get updates automatically.

**Integrate with your existing Jenkins plugins.** The `rhtap` library coexists with your current Jenkins plugins—SonarQube, Artifactory, Nexus, Slack notifications. Your Jenkinsfile can call `buildah_rhtap()` for container building and still call `sonarqubeScan()` for code quality checks.

**Expand Enterprise Contract policies.** Your workshop used default policies (validate signatures, check CVEs, verify provenance). Add organization-specific rules: "reject images with copyleft licenses," "require semantic versioning tags," "enforce specific base images from approved list."

**Deep dive into specific technologies:**

- **Jenkins Configuration as Code (JCasC)**: Currently Jenkins configuration is manual (creating jobs, installing plugins, configuring credentials). JCasC defines Jenkins configuration in YAML, version-controlled in Git. Rebuild Jenkins controller from code, no manual clicks.

- **Blue Ocean pipeline editor**: You wrote Jenkinsfiles manually. Blue Ocean provides visual pipeline builder that generates declarative Jenkinsfile syntax. Good for teams learning Jenkinsfiles.

- **Jenkins X**: Different from what you built (Jenkins+RHADS). Jenkins X is Kubernetes-native CI/CD that happens to use "Jenkins" branding but is actually Tekton under the hood. Don't confuse with enhanced Jenkins approach.

- **Shared library versioning**: Your `@Library('rhtap')_` uses latest version. Production pipelines should pin versions: `@Library('rhtap@v2.1')_`. This prevents breaking changes from affecting production builds.

== Additional Resources

**Red Hat Enhanced Jenkins Documentation:**

* link:https://developers.redhat.com/products/advanced-developer-suite[Red Hat Advanced Developer Suite^]
* link:https://docs.openshift.com/pipelines/[OpenShift Pipelines Integration^]
* link:https://developers.redhat.com/products/openshift-dev-spaces[OpenShift Dev Spaces^]

**Jenkins Enhancement Patterns:**

* link:https://www.jenkins.io/doc/book/pipeline/[Jenkins Pipeline Documentation^]
* link:https://plugins.jenkins.io/[Jenkins Plugin Ecosystem^]
* link:https://www.jenkins.io/doc/book/managing/security/[Jenkins Security Best Practices^]

**Enterprise Integration Resources:**

* link:https://www.redhat.com/en/solutions/trusted-software-supply-chain[Trusted Software Supply Chain^]
* link:https://access.redhat.com/documentation/[Red Hat Product Documentation^]
* link:https://developers.redhat.com/[Red Hat Developer Portal^]

== Thank You!

Thank you for completing the Enhanced Jenkins module! You've experienced how Red Hat Advanced Developer Suite preserves and enhances existing investments while providing modern capabilities.

**Continue Your Journey:**

* Explore the **OpenShift Pipelines (Tekton)** module to see alternative implementation approaches
* Review complete workshop resources and implementation planning materials
* Develop your organization's RHADS implementation strategy based on today's experience

*Your Jenkins enhancement journey begins with protected investments and modern capabilities!*
